/*
 * vm.c
 *
 *
 *
 * Copyright (C) 2013-03-18 liutos <mat.liutos@gmail.com>
 */
#include <stdio.h>
#include <stdlib.h>

#include "types.h"
#include "object.h"

extern void write_object(lisp_object_t, lisp_object_t);

enum code_type {
  CONST,
  LVAR,
};

enum code_type code_name(lisp_object_t code) {
#define S(name) find_or_create_symbol(name)
  lisp_object_t name = pair_car(code);
  if (S("CONST") == name)
    return CONST;
  if (S("LVAR") == name)
    return LVAR;
  fprintf(stderr, "Unsupported code: %s\n", symbol_name(pair_car(code)));
  exit(1);
}

lisp_object_t code_arg0(lisp_object_t code) {
  return pair_cadr(code);
}

lisp_object_t code_arg1(lisp_object_t code) {
  return pair_caddr(code);
}

lisp_object_t code_arg2(lisp_object_t code) {
  return pair_cadddr(code);
}

lisp_object_t get_variable_by_index(int i, int j, lisp_object_t environment) {
  while (i != 0) {
    environment = enclosing_environment(environment);
    i--;
  }
  lisp_object_t vals = environment_vals(environment);
  while (j != 0) {
    vals = pair_cdr(vals);
    j--;
  }
  return pair_car(vals);
}

/* Run the code generated by compiling an S-exp */
lisp_object_t ugly_machine(lisp_object_t compiled_code, lisp_object_t environment) {
  if (is_compiled_proc(compiled_code))
    compiled_code = compiled_proc_code(compiled_code);
  while (!is_null(compiled_code)) {
    lisp_object_t code = pair_car(compiled_code);
    switch (code_name(code)) {
      case CONST: return code_arg0(code);
      case LVAR: {
        int i = fixnum_value(code_arg0(code));
        int j = fixnum_value(code_arg1(code));
        return get_variable_by_index(i, j, environment);
      }
      default :
        fprintf(stderr, "Unknown code\n");
        exit(1);
    }
    compiled_code = pair_cdr(compiled_code);
  }
  return make_undefined();
}
